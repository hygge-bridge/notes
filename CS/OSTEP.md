# 第 4 章 抽象：进程

进程是什么？

什么是时分共享技术和空分共享技术？

## 4.1 抽象：进程

进程包含哪些？

## 4.2 进程 API 

## 4.3 进程创建：更多细节

程序如何转化为进程？或者说怎么启动一个进程？

## 4.4 进程状态

进程的基本状态有哪些？怎么转换的（画图）？

## 4.5 数据结构

除了基本状态，进程还有哪些状态？

# 第 5 章 插叙：进程 API

## 5.1 fork()系统调用

解释一下fork系统调用？

## 5.2 wait()系统调用

解释一下wait系统调用？

## 5.3 最后是 exec()系统调用

解释一下exec系统调用？

## 5.4 为什么这样设计 API

为什么要分离fork和exec？

# 第 6 章 机制：受限直接执行

## 6.1 基本技巧：受限直接执行

受限的直接执行中直接执行是什么意思？

## 6.2 问题 1：受限制的操作三

如何让一个进程可以做一些操作但是不可以完全控制操作系统的？

但是用户程序希望执行某些特权指令怎么办？

执行系统调用的过程？

## 6.3 问题 2：在进程之间切换

协作方式？非协作方式？时钟中断？

上下文切换？

# 第 7 章 进程调度：介绍

## 7.1 工作负载假设

## 7.2 调度指标

周转时间？

## 7.3 先进先出（FIFO）

fifo？优缺点？

## 7.4 最短任务优先（SJF）

sjf？

## 7.5 最短完成时间优先（STCF） 

stcf/psjf？

## 7.6 新度量指标：响应时间

响应时间？

## 7.7 轮转

轮转（Round-Robin， RR）调度？

## 7.8 结合 I/O 

重叠操作？

# 第 8 章 调度：多级反馈队列

## 8.1 MLFQ：基本规则 

mlfq的基本规则？

## 8.2 尝试 1：如何改变优先级

改变优先级的规则？

举例：来了单个长工作？来了一个短工作？如果有 I/O 呢 ？

缺点？

## 8.3 尝试 2：提升优先级

如何避免饥饿？

## 8.4 尝试 3：更好的计时方式 

如何防止mlfq被愚弄？

## 8.5 MLFQ 调优及其他问题

时间片怎么设置？

## 8.6 MLFQ：小结 

总结一下mlfq？

# 第 9 章 调度：比例份额

## 9.1 基本概念：彩票数表示份额 

彩票调度？

## 9.2 彩票机制 

彩票货币机制？彩票转让机制？彩票通胀机制？

## 9.3 实现

## 9.4 一个例子

## 9.5 如何分配彩票

没有好的实现。。。

## 9.6 为什么不是确定的 

步长调度？缺点？

# 第 10 章 多处理器调度（高级）

## 10.1 背景：多处理器架构

缓存？时间局部性和空间局部性？

缓存一致性问题？解决方案？

## 10.2 别忘了同步

就是加锁啥的。

## 10.3 最后一个问题：缓存亲和度

缓存亲和度？

## 10.4 单队列调度

单队列多处理器调度（sqms）？

## 10.5 多队列调度 

多队列多处理器调度（Multi-Queue Multiprocessor Scheduling，MQMS）？

迁移？工作窃取？

## 10.6 Linux 多处理器调度 

# 第 13 章 抽象：地址空间

## 13.1 早期系统

## 13.2 多道程序和时分共享

#### 时分共享内存的实现？

让一个进程单独占用全部内存运行一小段时间，然后停止他，并将它所有的状态信息保存在内存中，然后加载其他进程的状态信息，从而运行。

ps：不能把状态信息保存在磁盘，这样会导致性能太低了。

## 13.3 地址空间

#### 地址空间？

不希望一个进程可以读取其他进程的内存，更别说修改了。所以os提供了一个易用的物理内存抽象，也就是进程看到的系统的内存。（隔离性）

#### 进程地址空间包含内容？

包含进程的所有内存状态：代码、栈、堆、静态初始化的变量等

#### 如何虚拟化内存？

os在硬件的支持下，必须确保进程的虚拟地址加载到对应的物理地址上。

## 13.4 目标 

#### 虚拟化内存的目标？

透明+效率+保护

# 第 14 章 插叙：内存操作 API

## 14.1 内存类型

#### 栈内存和堆内存？

- 栈内存的申请和释放操作是编译器来隐式管理
- 堆内存的申请和释放操作都由程序员显式地完成

## 14.2 malloc()调用

申请堆内存：

```
#include <stdlib.h>
void *malloc(size_t size);
```

注意如下sizeof的用法：(32位系统)

```
int *x = malloc(10 * sizeof(int)); // 3sizeof(x) = 4
int x[10]; // sizeof(x) = 40
```

为字符串申请空间时，注意strlen返回的是字符串长度，分配空间时必须注意长度加上一个1，便于为字符串结束符留出空间：

```
malloc(strlen(s) + 1);
```

## 14.3 free()调用

释放堆内存：

```
void free(void *ptr);
```

内存大小是由内存分配库自身跟踪的

## 14.4 常见错误

忘记分配内存：

```
char *src = "hello";
char *dst; // oops! unallocated
strcpy(dst, src); // segfault and die 

正确代码如下：
char *src = "hello";
char *dst = (char *) malloc(strlen(src) + 1);
strcpy(dst, src); // work properly
```

没有分配猪狗的内存（缓冲区溢出）：

```
char *src = "hello";
char *dst = (char *) malloc(strlen(src)); // too small!
strcpy(dst, src); // work properly 
```

忘记初始化分配的内存：调用malloc后，记得初始化

忘记释放内存：如果程序运行时间很短且很快退出，那么进程死亡时，os会清理分配的所有页面，所以这样子不会内存泄漏。但是记得保持良好习惯！！！

在用完之前释放内存 ：在程序结束前释放内存---悬挂指针(dangling pointer)

反复释放内存：不止一次释放内存---重复释放(double free)

错误地调用free()：free只希望我们传入之前malloc()得到的指针，不要传其他值

查找内存bug的相关工具：purify+valgrind

## 14.5 底层操作系统支持 

## 14.6 其他调用

calloc()会在函数返回前将内存置零

realloc会创建一个新的更大的内存区域，然后把旧区域复制过来，并返回新区域的指针

# 第 15 章 机制：地址转换

#### 实现cpu虚拟化时遵循的受限直接访问（Limited Direct Execution，LDE）？

让程序运行的大部分指令直接访问硬件，只在一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确时间， 正确的地点，做正确的事”

# 15.1 假设 

## 15.2 一个例子

#### 介入技术？

在虚拟内存中， 硬件可以介入到每次内存访问中，将进程提供的虚拟地址转换为数据实际存储的物理地址。

## 15.3 动态（基于硬件）重定位

#### 动态重定位和静态重定位？

##### 静态重定位：

- 纯软件的重定位方式，一个名为加载程序（loader）的软件接手将要运行的可执行程序，将它的地址重写到物理内存中期望的偏移位置。
- 静态重定位问题：不提供访问保护，重定位一旦完成那么内存空间很难重定位到其他位置

##### 动态重定位：

- 每个 CPU 需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存 器，有时称为限制（limit）寄存器。它们让我们能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间。
  - 硬件获取指令地址时，会将这个值加上基址寄存器的值，从而得到实际的物理地址，然后硬件从这个物理地址上获取指令并执行。
  - 当进程访问超过界限寄存器的值时，cpu会触发异常，进程就可能会终止。界限寄存器就可以确保进程产生的所有地址都在进程的地址“界限”中。
- 基址寄存器和界限寄存器补充说明：
  - 基址寄存器配合界限寄存器的硬件结构是芯片中的（每个cpu一对），cpu中负责地址转换的部分被称作mmu内存管理单元。
  - 界限寄存器有两种实现：
    - 记录地址空间大小，硬件在虚拟地址和寄存寄存器内容求和前，检查界限（后续介绍都采用的这种）
    - 记录地址空间结束的物理地址，硬件将那个虚拟地址转换到物理地址后再去检查界限

## 15.4 硬件支持：总结

## 15.5 操作系统的问题

## 15.6 小结

#### 内部碎片？

是已经分配的内存单元内部有未使用的空间（即碎片），造成了浪费

# 第 16 章 分段