# 32 一致性哈希算法-负载均衡算法

### 一致性哈希算法

集群服务器环境下：需要通过反向代理（负载均衡）服务器将用户的请求分发到合适的服务器上。

常见的负载均衡算法有：轮询、哈希、权重比、最少连接算法。这些算法相对简单，但是会有问题。一致性哈希算法才是分布式系统负载均衡的首选算法。

#### 利用哈希算法处理如下场景？

接入机负载均衡后端的N台服务器，接入机接收到请求后，需要将请求平均分发到每台服务器上，理论上希望每台服务器可以负责1/n的服务处理。

##### 方案：

`hash(ip:port) mod N`：因为服务器的ip和端口号组合起来一定不同，用一个哈希算法将二者处理得到一个整数（如md5），然后再来进行除留余数法。这样子就知道了接受请求的服务器。

##### 好处：

- 同一个客户端，会被永远映射到一台服务器上。
- 可以有效解决会话共享问题。会话会包含用户的状态、连接等信息。

如果用户的请求没有映射到同一台服务器，那么我就需要借助缓存服务器了，然后将会话全部保存到里面。每次取会话都去缓存服务器中取。如果不，那么我下一次映射到其他服务器时，比如集群聊天器的情况，服务器会误认为该用户没有登录，但其实该用户已经在一个服务器上登录了。

##### 坏处：

- 如果有一台机器挂掉了，那么哈希处理时mod的数字就少了1，那么我的用户后续再发的请求就不一定会到达原来的服务器了。
- 增加了一台服务器同理。

显然普通的哈希算法没有良好的单调性，即服务器节点的增减会造成大量哈希的重定位。

#### 一致性哈希算法？

##### 方案：

1. 一致性哈希算法是将哈希值逻辑上理解成一个环，取值范围为0-2^32-1共4g的整数空间（其实就是unsigned int的取值范围）；
2. 将所有服务器进行哈希，最终落在一致性哈希环上。假设ABC三台服务器，哈希后的位置如下（如果三台服务都在一台机器上，就加上端口号一起哈希，不过这种情况很少）；![image-20240510124001366](C:\Users\Mr.Helen\AppData\Roaming\Typora\typora-user-images\image-20240510124001366.png)
3. 在进行负载时，也就是用户请求来了，先将输入值（ip+port）进行哈希从而得到一致性哈希环上的一个哈希值，然后沿着顺时针，遇到的第一台服务器，就是最后负载到的服务器。如图：1号请求就应该落到A服务器，其余同理；![image-20240510124514834](C:\Users\Mr.Helen\AppData\Roaming\Typora\typora-user-images\image-20240510124514834.png)

##### 容错性和可扩展性分析：

- 当有节点挂掉了，只需要将当前节点的用户交给沿着顺时针方向的下一个节点就好了。比如A服务器挂了，那就将1号用户交给C服务器。
- 增加节点时，只需要将新节点沿着逆时针方向到上一台节点的请求会落在新节点上。比如新节点D落在了2和3号用户哈希值的中间，那么2号用户就会被重新映射到D上，其余的用户请求不受影响。

##### 没有虚拟节点的一致性哈希算法缺点：

服务器经过一致性哈希算法处理后，在哈希环上应该分散一点好。这样子可以让负载相对均衡一点。因为假如很多请求都落在一台服务器上，那就会导致某些服务器负载太多，但是其他服务器一直很空闲。

##### 虚拟节点：

- 将一台服务器虚拟成多个节点，比如b服务器可以虚拟成b0、b1等，然后将他们的ip设置为ip#0、ip#1等。虽然ip只有一个值不同，但是通过md5算法处理后，结果也是非常离散的。（虚拟节点的ip设置可以自己选择的，不是固定的）一般情况下会有100-200个虚拟节点。
- 虚拟节点中会保存对应的物理节点的信息。比如有个请求落在了b1，实际上就会被映射到b服务器。

#### md5算法？

md5算法的主要用处：加密、哈希、验证、云盘、大文件传输（秒传）

##### md5在传输文件到文件服务器时，防止文件在传输过程中被恶意修改的方式：

1. 首先打包好消息序列化（json/protobuf等）信息：消息类型（上传信息等）、文件信息（文件名、文件大小、文件的md5值等），传输文件前需要发送消息，等待服务器同意
2. 然后开始传输文件，文件服务器接受文件后计算一个这个文件的md5值
3. 这个md5值应该和在客户端计算的md5值一样，否则就表示被修改了

##### md5实现秒传的逻辑：

在上传文件时，因为上传信息会有md5值，如果服务端发现md5值已经有了，这就代表服务器已经有该文件了，那么就直接回复文件上传成功的信息。其实根本就没有真正执行上传操作。
